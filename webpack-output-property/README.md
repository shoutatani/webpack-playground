# 何のためのディレクトリか

- webpack の [output オプション](https://webpack.js.org/configuration/output/) のうち、[output.library オプション](https://webpack.js.org/configuration/output/#outputlibrary)を変更した場合にどのように成果物が変わるのか、実際に見てみたかったがために作ったディレクトリ。
  - output.library オプションを変更した場合に、エントリーポイントからエクスポートされたモジュールがどのように利用可能になるのか見てみた。

# 何が観測できたのか

- [output.library.type オプション](https://webpack.js.org/configuration/output/#outputlibrarytype) は、それぞれ以下の通り使えることがわかった。
  - output.library.type オプションが、変数を用いた代入によるモジュールの受け渡しの場合
    - [type: "var"](https://webpack.js.org/configuration/output/#type-var) の場合
      - バンドルされたエントリーポイントのトップレベルで `var <library.name>;`と宣言され、そこに紐付けられることが見て取れた。
      - したがって、読み込まれた空間で(script タグ等を使って読み込んだ場合はグローバル空間で)、そのまま <library.name> として利用可能になる。
        - 上記の宣言は、Node.js では、JavaScript ファイルのスコープ内でのみ利用可能な変数となってしまうため、他ファイルからは利用できない。
    - [type: "assign"](https://webpack.js.org/configuration/output/#type-assign) の場合
      - バンドルされたエントリーポイントで `<library.name> = エクスポートするもの;` と、紐付けられることが見て取れた。これは、既存の宣言があればそこに直接 assign され、既存の宣言がなければグローバルスコープとして利用可能になるということ。
        - つまり、`var <library.name> = {a: 1};` などと宣言していた場合、 `{a: 1}` の既存のオブジェクトを上書きすることになる。
      - したがって、読み込まれた空間において(script タグ等を使って読み込んだ場合はグローバル空間において)、そのまま <library.name> として利用可能になる。
        - これに関しても、Node.js では上記の宣言は、JavaScript ファイルのスコープ内でのみ利用可能な変数となってしまうため、他ファイルからは利用できない。
    - [type: "assign-properties"](https://webpack.js.org/configuration/output/#type-assign-properties) の場合
      - バンドルされたエントリーポイントで、 `<library.name>[キー名] = エクスポートするもの;` と、紐付けられることが見て取れた。これは、既に対象のオブジェクトがあればそのプロパティに追記し、オブジェクトが無ければ新しいオブジェクトを与えたうえでそのプロパティに追記することが確認できた。
        - つまり、`var <library.name> = {a: 1};` などと宣言していた場合、 `{a: 1, <exported_key>: <exported_object>}` として、既存のオブジェクト上書きすることなくエクスポートされたオブジェクトが利用できるようになる。
        - まだ対象の変数にオブジェクトが紐付けられていなければ、 `{<exported_key>: <exported_object>}` の形のオブジェクトがバインドされることになる。
      - したがって、読み込まれた空間において(script タグ等を使って読み込んだ場合はグローバル空間において)、そのまま <library.name> として利用可能になる。
        - これに関しても、Node.js では上記の宣言は、JavaScript ファイルのスコープ内でのみ利用可能な変数となってしまうため、他ファイルからは利用できない。
    - [type: "this"](https://webpack.js.org/configuration/output/#type-this) の場合
      - バンドルされたエントリーポイントで、 `this.<library.name> = エクスポートするもの;` と、紐付けられることが見て取れた。
        - したがって、ブラウザ環境で `this` に `window` オブジェクト紐付いている場合には、 `window.<library.name>` として利用可能になることがわかった。
        - また、Node.js 環境向けとして `target: "node"` で出力した場合には、ライブラリ内で `this` は `module.exports` に紐付くので、CommonJS として `const { <exported_key> } = require("<library.name>")` として呼び出すことも可能となる。
      - 読み込まれた空間において(script タグ等を使って読み込んだ場合はグローバル空間において)、 `this` に相当するオブジェクトに紐づくので、利用シーンに応じて呼び出し方を考えなければいけないことがわかった。
    - [type: "window"](https://webpack.js.org/configuration/output/#type-window) の場合
      - バンドルされたエントリーポイントで、 `window.<library.name> = エクスポートするもの;` と、紐付けられることが見て取れた。
        - したがって、ブラウザ環境では `window.<library.name>` として利用可能になることがわかった。
    - [type: "global"](https://webpack.js.org/configuration/output/#type-global) の場合
      - バンドルされたエントリーポイントで、 `self.<library.name> = エクスポートするもの;` (web 環境) や `global.<library.name> = エクスポートするもの;` (Node.js 環境) などと、`target` オプションに応じた `global` オブジェクトに紐付けられることが見て取れた。
        - したがって、ブラウザ環境では `window.<library.name>` や `globalThis.<library.name>` として、Node.js 環境では `global.<library.name>` や `globalThis.<library.name>` として、利用可能になることがわかった。
    - [type: "commonjs"](https://webpack.js.org/configuration/output/#type-commonjs) の場合
      - バンドルされたエントリーポイントで、 `exports.<library.name> = エクスポートするもの;` と、紐付けられることが見て取れた。
        - これは、https://github.com/webpack/webpack/issues/1114#issuecomment-931050560 にて詳細に解説されている通り、`commonjs` の設定はあくまで CommonJS の仕様に基づいて `exports` オブジェクトに対してエクスポートする、という仕様を実現しており、それは Node.js の exports/require に対応しているものではなく、Node.js の `require` では読み込めないことを確認できた。
          - `dist/output-library-type-commonjs-on-node/entry.js` を見れば分かる通り、`target: "node"` で出力した場合、ローカルで`var exports = {};` と exports を独自に宣言してしまっているため、Node.js の `require` で読み込めるものではなかった。(Node.js のモジュールで渡されるはずの `exports` オブジェクトを隠蔽してしまっている)
          - 一方で、`dist/output-library-type-commonjs/entry.js` を見れば分かる通り、`target: "web"` で出力した場合、 `exports.<library.name> = エクスポートするもの;` としているため、エントリーポイントのスコープで宣言した `exports` オブジェクトに対して紐付けられることがわかった。
          - よって、CommonJS の仕様を解釈して処理する独自の処理系を作るのであれば、それに応じた独自の target タイプを構築し、そこで自ら webpack が生成した `exports` をハンドリングするよう期待されているものと思われる。
      - したがって、web 環境で使う場合には、`assign` の場合と同様に、既に宣言された `exports` オブジェクトにエクスポートした対象が紐づくことになるので、 `exports.<library.name>` として利用可能になることがわかった。
  - output.library.type オプションが、モジュールシステムを用いたモジュールの受け渡しの場合
    - ["type: "module"](https://webpack.js.org/configuration/output/#type-module) の場合
      - バンドルされたエントリーポイントで、 `export { エクスポートするもの };` と、バンドル前同様にエクスポートされることが見て取れた。
        - 説明にある通り、2022/04 時点では、`experiments.outputModule` を `true` にしないと出力できない。
        - また、target プロパティに関して、web 環境の場合は `es2020` 以上の指定が必要で、Node.js 環境の場合は `node12.7` 以上の指定が必要となっている。
          - 参考：https://github.com/webpack/webpack/blob/v5.72.0/lib/config/target.js#L180
      - したがって、`import { エクスポートしたもの } from "バンドルしたファイル";` で利用可能になることが確認できた。
    - ["type: "commonjs2"](https://webpack.js.org/configuration/output/#type-commonjs2) の場合
      - バンドルされたエントリーポイントで、名前付きエクスポートをした場合、 `module.exports = エクスポートするものの集合;` と、紐付けられることがわかった。
        - ※ ソースコードから ES Modules で名前付きエクスポートを行った場合で試したが、ベースが CommonJS でも変わらないだろう。
      - したがって、`const { エクスポートしたもの } = require("バンドルしたファイル");` で利用可能になることが確認できた。
        - 同様の type オプションに `commonjs` オプションがあるが、大多数の人が必要としているのはこちらだろう。
    - ["type: "commonjs-static"](https://webpack.js.org/configuration/output/#type-commonjs-static) の場合
      - バンドルされたエントリーポイントで、 `exports.<exported_key> = エクスポートするものの集合.<exported_key>;` と、紐付けられることが見て取れた。
        - この `commonjs-static` オプションについても、 `commonjs` オプションの場合と同様に、`target: "node"` の場合には、ローカル変数として `exports` が宣言されているために Node.js の環境からは読み込めない形となっており、また同様に、`target: "web"` の場合には、エントリーポイントのスコープで宣言した `exports` オブジェクトに対して紐付けられることがわかった。
      - したがって、web 環境で使う場合には、既に宣言された `exports` オブジェクトにエクスポートした対象が紐づくことになるので、 `exports.<exported_key>` として利用可能になることがわかった。
        - Node.js 環境で使用できないので、自分の勘違いなのではないかと思ってしまっている。
    - ["type: "amd"](https://webpack.js.org/configuration/output/#type-amd) の場合
      - amd 形式/RequireJS について詳しくないため、出力だけ行ってみたが、`define` オブジェクトを使ったアウトプットが確認できた。
    - ["type: "amd-require"](https://webpack.js.org/configuration/output/#type-amd-require) の場合
      - amd 形式/RequireJS について詳しくないため、出力だけ行ってみたが、`require` オブジェクトを使ったアウトプットが確認できた。
    - ["type: "umd"](https://webpack.js.org/configuration/output/#type-umd) の場合
      - バンドルされたエントリーポイントで、名前付きエクスポートをした場合、 `module.exports` が使える場合(Node.js 環境の場合)は `module.exports = エクスポートするものの集合;` と紐付けられ、次に `define` が使える場合(AMD 形式がサポートされている場合)は、 `define([], <エクスポートするものの集合を返す関数>)` と紐付けられ、次に `exports` が使える場合(CommonJS のピュアな仕様の場合)は、 `exports[<ライブラリ名>] = エクスポートするものの集合` と紐付けられ、それ以外の場合には `<output.globalObjectが示すグローバルオブジェクト>[<ライブラリ名>] = エクスポートするものの集合` と紐付けられることがわかった。
        - この検証パッケージを作る際、umd のベースとなる各設定を確かめたいがために作ったという背景があったので、ようやくここにたどり着けて感無量。
        - なおチャンクを分割してしまうと、バンドルしてできたライブラリがどのように読み込まれるのかを限定してしまうことになるので、今回は webpack のモジュールコアをバンドルファイルに組み込んで検証した。
      - したがって、読み込む環境に応じて適切に呼び出せば、webpack がファサードの役目を果たして様々なモジュールシステムから呼び出せるようになることがわかった。
        - 自分で分岐を作ってバンドルファイルを作ることもできるが、そんなメリットは無い。
    - ["type: "system"](https://webpack.js.org/configuration/output/#type-system) の場合
      - SystemJS 形式 について詳しくないため、出力だけ行ってみたが、`System.register` オブジェクトを使ったアウトプットが確認できた。
